/*
 * stm32_f446xx_gpio_driver.c
 *
 *  Created on: Feb 2, 2026
 *      Author: My PC
 */


#include "stm32_f446xx_gpio_driver.h"

/**
 * @fn        GPIO_PerClockControl
 * @brief     Enables or disables the peripheral clock for the specified GPIO port.
 *
 * @param[in] pGPIOx  Base address of the GPIO peripheral (e.g., GPIOA, GPIOB)
 * @param[in] EnorDi  Macro to enable or disable the clock (ENABLE or DISABLE)
 *
 * @return    None
 *
 * @note      This must be called before using any GPIO functions on the port.
 */



 void GPIO_PericClockControl(GPIO_RegDef_t *pGPIOx, uint8_t EnorDi)
{
	if (EnorDi == ENABLE)
	{
		if (pGPIOx == GPIOA)
		{
			GPIOA_PCLK_EN();
		}
		else if(pGPIOx == GPIOB)
		{
			GPIOB_PCLK_EN();
		}
		else if (pGPIOx == GPIOC)
		{
			GPIOC_PCLK_EN();
		}
		else if(pGPIOx == GPIOD)
		{
			GPIOD_PCLK_EN();
		}
		else if (pGPIOx == GPIOE)
		{
			GPIOE_PCLK_EN();
		}
		else if(pGPIOx == GPIOF)
		{
			GPIOF_PCLK_EN();
		}
		else if (pGPIOx == GPIOG)
		{
			GPIOG_PCLK_EN();
		}
		else if(pGPIOx == GPIOH)
		{
			GPIOH_PCLK_EN();
		}

	}
	else
	{
		if (pGPIOx == GPIOA)
		{
			GPIOA_PCLK_DI();
		}
		else if(pGPIOx == GPIOB)
		{
			GPIOB_PCLK_DI();
		}
		else if (pGPIOx == GPIOC)
		{
			GPIOC_PCLK_DI();
		}
		else if(pGPIOx == GPIOD)
		{
			GPIOD_PCLK_DI();
		}
		else if (pGPIOx == GPIOE)
		{
			GPIOE_PCLK_DI();
		}
		else if(pGPIOx == GPIOF)
		{
			GPIOF_PCLK_DI();
		}
		else if (pGPIOx == GPIOG)
		{
			GPIOG_PCLK_DI();
		}
		else if(pGPIOx == GPIOH)
		{
			GPIOH_PCLK_DI();
		}
	}
}


	/**
	 * @fn           	GPIO_Init
	 * @brief    	 	This function initialise the GPIO port pin.
	 *
	 * @param[in] 		pGPIO_Handle_t pointer to GPIO handle structure
	 *
	 *
	 * @return    		None
	 *
	 * @note		    refer macros for gpio configuration
	 */


void GPIO_Init(GPIO_Handle_t *pGPIOHandle)
{
	uint32_t temp=0;
	// enable the peripheral clock
	GPIO_PericClockControl(pGPIOHandle->pGPIOx,ENABLE);

	//1 Configure GPIO MODE
	if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode <= GPIO_MODE_ANALOG)
	{
		temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode) << (2*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber); //to create a temp mask
		(pGPIOHandle->pGPIOx->MODER) &= ~(0x03 << (2*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); // to clear the register
		(pGPIOHandle->pGPIOx->MODER) |= temp;  //set the value of the register
		temp=0;
	}
	// INTERRUPT Modes
	else
	{
		if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IT_FT)
		{

		}
		else if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IT_RT)
		{

		}
		else if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IT_RFT)
		{

		}
	}

	//2 Configure speed
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinSpeed) << (2*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber); //to create a temp mask
	(pGPIOHandle->pGPIOx->OSPEEDER) &= ~(0x03 << (2*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); // to clear the register
	(pGPIOHandle->pGPIOx->OSPEEDER) |= temp;  //set the value of the register
	temp=0;

	//3 Configure PUPDR
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinPuPdControl) << (2*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber); //to create a temp mask
	(pGPIOHandle->pGPIOx->PUPDR) &= ~(0x03 << (2*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); // to clear the register
	(pGPIOHandle->pGPIOx->PUPDR) |= temp;  //set the value of the register
	temp=0;

	//4 Configure OTYPER
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinOPType) << (pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber); //to create a temp mask
	(pGPIOHandle->pGPIOx->OTYPER) &= ~(0x1 << (pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); // to clear the register
	(pGPIOHandle->pGPIOx->OTYPER) |= temp;  //set the value of the register
	temp=0;

	//temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinAltFunMode) << (4*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
	//(pGPIOHandle->GPIO_PinConfig.GPIO_PinAltFunMode) &= ~(0xF << (4*pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
	//(pGPIOHandle->GPIO_PinConfig.GPIO_PinAltFunMode) |= temp;
}
void GPIO_DeInit(GPIO_RegDef_t *pGPIOx)
{

}

/**
 * @fn        		GPIO_ReadFromInputPin
 *
 * @brief    		This function is used to read the value in a gpio pin .
 *
 * @param[in] 		GPIO_RegDef_t pointer to GPIO GPIO_RegDef_t structure
 *
 * @param[in]		PinNumber
 *
 * @return    		uint8_t value (value inside that pin)
 *
 * @note      		refer macros for gpio configuration
 */
uint8_t  GPIO_ReadFromInputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber)
{
	uint8_t value;
	value = (uint8_t) ((pGPIOx->IDR)>>(PinNumber) & 0x00000001);
	return value;
}

/**
 * @fn        		GPIO_ReadFromInputPort
 *
 * @brief    		This function is used to read the value in a gpio port .
 *
 * @param[in] 		GPIO_RegDef_t pointer to GPIO GPIO_RegDef_t structure
 *
 * @param[in]		PinNumber
 *
 * @return    		uint8_t value (value inside that pin)
 *
 * @note      		refer macros for gpio configuration
 */
uint16_t GPIO_ReadFromInputPort(GPIO_RegDef_t *pGPIOx)
{
	uint16_t value;
	value =(uint16_t)(pGPIOx->IDR);
	return value;
}

/**
 * @fn        		GPIO_WriteToOutputPin
 *
 * @brief    		This function is used to read the value in a gpio port .
 *
 * @param[in] 		GPIO_RegDef_t pointer to GPIO GPIO_RegDef_t structure
 *
 * @param[in]		PinNumber
 *
 * @return    		uint8_t value (value inside that pin)
 *
 * @note      		refer macros for gpio configuration
 */

void GPIO_WriteToOutputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber, uint16_t Value)
{
	if(Value ==1)
	{
		(pGPIOx->ODR) |= (1<< PinNumber);
	}
	else
	{
		(pGPIOx->ODR) &= ~(1<< PinNumber);
	}
}


void GPIO_WriteToOutputPort(GPIO_RegDef_t *pGPIOx, uint16_t Value)
{
	pGPIOx->ODR = Value;

}
void GPIO_ToggleOutputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber)
{
	(pGPIOx->ODR) ^= (1<<PinNumber);

}
